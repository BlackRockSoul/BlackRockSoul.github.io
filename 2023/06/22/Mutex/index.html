<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Refetch Access Token using Mutex-Async in a TypeScript, React, Redux-Toolkit Application</title><meta name="description" content="Explore. Build. Inspire."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-6GVSDQB599"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-DGP93TCT38');
</script><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><script src="/js/highlightjs-line-numbers.min.js"></script><meta name="description" content="Handling token expiry and error scenarios is a critical aspect of building secure and reliable web applications.
Let’s explore the complexities of refreshing access tokens, addressing 401 errors, and ensuring a seamless user experience.



The Challenge of Concurrent Token Refetch RequestsInitially, the task at hand was to reduce the lifespan of the access.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="BlackRockSoul" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">BlackRockSoul's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Refetch Access Token using Mutex-Async in a TypeScript, React, ..</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Challenge-of-Concurrent-Token-Refetch-Requests"><span class="toc-text">The Challenge of Concurrent Token Refetch Requests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leveraging-a-Mutex-Pattern-for-Synchronization"><span class="toc-text">Leveraging a Mutex Pattern for Synchronization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actually-refetching-token"><span class="toc-text">Actually refetching token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/React"><i class="tag post-item-tag">React</i></a><a href="/tags/TypeScript"><i class="tag post-item-tag">TypeScript</i></a><a href="/tags/Redux"><i class="tag post-item-tag">Redux</i></a><a href="/tags/Redux-Toolkit"><i class="tag post-item-tag">Redux-Toolkit</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Refetch Access Token using Mutex-Async in a TypeScript, React, Redux-Toolkit Application</h1><time class="has-text-grey" datetime="2023-06-22T09:48:40.000Z">June 22, 2023</time><article class="mt-2 post-content"><p>Handling token expiry and error scenarios is a critical aspect of building secure and reliable web applications.</p>
<p>Let’s explore the complexities of refreshing access tokens, addressing 401 errors, and ensuring a seamless user experience.</p>
<span id="more"></span>

<hr>
<h2 id="The-Challenge-of-Concurrent-Token-Refetch-Requests"><a href="#The-Challenge-of-Concurrent-Token-Refetch-Requests" class="headerlink" title="The Challenge of Concurrent Token Refetch Requests"></a>The Challenge of Concurrent Token Refetch Requests</h2><p>Initially, the task at hand was to reduce the lifespan of the access token to 5 minutes for enhanced security.<br>So the first step was to introduce a refresh token and use it to update the access token whenever it expired or when the server returned a 401 error.</p>
<p>Refreshing the token based on its expiration time proved to be a straightforward task. As I thought.<br>However, addressing the 401 error presented a more complex challenge.</p>
<p>My initial implementation for token refetch was flawed, as it failed to handle the scenario effectively.</p>
<p>One of the major issues with the initial solution was that when a page with multiple requests loaded, each request received a 401 response and attempted to refresh the token independently.<br>This concurrent nature of the requests resulted in a race condition. It was not only inefficient but also led to undesired behavior.</p>
<p>To overcome this challenge, I revisited a previous project, Time3cker, where I had implemented authentication. Upon reviewing the code, I discovered a relevant snippet:</p>
<pre><code class="hljs tsx"><span class="hljs-keyword">public</span> getToken = <span class="hljs-keyword">async</span> (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; =&gt; &#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">regainTokenPromise</span>) <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">regainTokenPromise</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isTokenExpired</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span>)) <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">regainToken</span>();

  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Access token is not available&#x27;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span>;
&#125;;</code></pre>

<p>In this code snippet, when requesting the token, it first checks for the presence of a promise for token refetch.<br>If a promise exists, it waits until it resolves or rejects.<br>Then, it just verifies if the token is valid. And if not, it simply waits for the token to be refreshed.</p>
<p>Implementing a similar approach seemed promising to address the race condition and ensure that all other requests would wait for the token to be refreshed first.</p>
<h2 id="Leveraging-a-Mutex-Pattern-for-Synchronization"><a href="#Leveraging-a-Mutex-Pattern-for-Synchronization" class="headerlink" title="Leveraging a Mutex Pattern for Synchronization"></a>Leveraging a Mutex Pattern for Synchronization</h2><p>Inspired by the concept I encountered in the previous project, I recalled that the mutex pattern could prevent concurrent access to a shared resource, which was precisely the behavior I needed for the token refetching mechanism.<br>And just decided to leverage a mutex pattern to synchronize the token refetch process.</p>
<p>It was kind of straightforward. I just installed the <code>async-mutex</code> library which provides a simple and reliable implementation of the mutex pattern.</p>
<pre><code class="hljs bash">yarn add async-mutex</code></pre>

<p>The mutex pattern ensures exclusive access to a shared resource. And in my case it just allows preventing concurrent token refreshes and effectively resolve the racing.</p>
<p>Let’s see on the code:</p>
<pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; fetchBaseQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./baseQuery&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Mutex</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;async-mutex&quot;</span>;

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">const</span> mutex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mutex</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">baseQueryWithReauth</span>: <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> fetchBaseQuery&gt; = <span class="hljs-keyword">async</span> (
  args,
  api,
  extraOptions
): <span class="hljs-title class_">Promise</span>&lt;
  <span class="hljs-title class_">QueryReturnValue</span>&lt;<span class="hljs-built_in">unknown</span>, <span class="hljs-title class_">FetchBaseQueryError</span>, <span class="hljs-title class_">FetchBaseQueryMeta</span>&gt;
&gt; =&gt; &#123;
  <span class="hljs-comment">// Wait for mutex unlock before doing anything</span>
  <span class="hljs-keyword">await</span> mutex.<span class="hljs-title function_">waitForUnlock</span>();

  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">baseQuery</span>(args, api, extraOptions);

  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRevalidateTokenError</span>(result.<span class="hljs-property">error</span>)) &#123;
    <span class="hljs-comment">// Check if mutex is locked</span>
    <span class="hljs-keyword">if</span> (mutex.<span class="hljs-title function_">isLocked</span>()) &#123;
      <span class="hljs-comment">// Wait for mutex unlock and retry the same query</span>
      <span class="hljs-keyword">await</span> mutex.<span class="hljs-title function_">waitForUnlock</span>();
      result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">baseQuery</span>(args, api, extraOptions);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// Lock mutex to perform token refresh</span>
      <span class="hljs-keyword">const</span> release = <span class="hljs-keyword">await</span> mutex.<span class="hljs-title function_">acquire</span>();

      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// Token refresh logic</span>
        <span class="hljs-comment">// ...</span>
      &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// Unlock mutex</span>
        <span class="hljs-title function_">release</span>();
      &#125;
    &#125;
  &#125;

  <span class="hljs-comment">// Handle error and return result</span>
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<p>Code ensures exclusive access during token refresh by utilizing the mutex pattern:</p>
<ol>
<li><p>Before initiating any token-related operations, it awaits the mutex to be unlocked using <code>await mutex.waitForUnlock()</code>.<br>This ensures that any concurrent requests will wait until the mutex is released.</p>
</li>
<li><p>If a 401 error occurs (<code>isRevalidateTokenError</code>) and the mutex is not locked, it simply calls the <code>mutex.acquire()</code>.<br>This locks the mutex, preventing other requests from simultaneously executing the token refresh logic and prevents any other queries from executing.</p>
</li>
<li><p>Inside the mutex-protected block, I perform the token refresh logic, such as fetching the <code>refresh</code> API endpoint and updating the tokens.</p>
</li>
<li><p>Finally, it just releases the mutex using <code>release()</code> to unlock it and allow other requests to proceed.</p>
</li>
</ol>
<p>By utilizing the Mutex class from the <code>async-mutex</code> package, I ensured that only one thread could acquire the mutex lock at a time.<br>This guaranteed exclusive access to the token refetch logic, preventing concurrent token refresh operations.</p>
<h2 id="Actually-refetching-token"><a href="#Actually-refetching-token" class="headerlink" title="Actually refetching token"></a>Actually refetching token</h2><p>With mutex I made a wrapper for the refetch.<br>Let’s go into a little more detail:</p>
<pre><code class="hljs tsx"><span class="hljs-keyword">try</span> &#123;
  <span class="hljs-comment">// Trying to fetch the `refresh` API endpoint with `refreshToken`</span>
  <span class="hljs-keyword">const</span> refreshTokenResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">baseQuery</span>(
    &#123;
      <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/auth/refresh&quot;</span>,
      <span class="hljs-comment">// Let the `baseQuery` handle header management</span>
      <span class="hljs-attr">headers</span>: &#123; <span class="hljs-title class_">Authorization</span>: <span class="hljs-variable constant_">REFRESH_TOKEN_PLACEHOLDER</span> &#125;,
    &#125;,
    api,
    extraOptions
  );

  <span class="hljs-comment">// ...</span>
&#125;</code></pre>

<p>So when a token refresh is required, it initiates a request to the <code>/auth/refresh</code> API endpoint with the <code>refreshToken</code>.</p>
<p>I delegate the header management to <code>baseQuery</code>. I try to keep the same logic in one place, so there’s no conflict later.<br>Let’s see:</p>
<pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REFRESH_TOKEN_PLACEHOLDER</span> = <span class="hljs-string">&quot;_REFRESH_TOKEN_&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE_URL</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">REACT_APP_SERVER_ENDPOINT</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baseQuery = <span class="hljs-title function_">fetchBaseQuery</span>(&#123;
  <span class="hljs-attr">baseUrl</span>: <span class="hljs-variable constant_">BASE_URL</span>,
  <span class="hljs-attr">prepareHeaders</span>: <span class="hljs-function">(<span class="hljs-params">headers, &#123; getState &#125;</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (headers.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;Authorization&quot;</span>) === <span class="hljs-variable constant_">REFRESH_TOKEN_PLACEHOLDER</span>) &#123;
      <span class="hljs-keyword">const</span> &#123; refreshToken &#125; = (<span class="hljs-title function_">getState</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">RootState</span>).<span class="hljs-property">sessionState</span>;

      <span class="hljs-keyword">if</span> (refreshToken) headers.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;refreshToken&#125;</span>`</span>);
      <span class="hljs-keyword">else</span> headers.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;Authorization&quot;</span>);
      <span class="hljs-keyword">return</span> headers;
    &#125;

    <span class="hljs-keyword">const</span> &#123; accessToken &#125; = (<span class="hljs-title function_">getState</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">RootState</span>).<span class="hljs-property">sessionState</span>;
    <span class="hljs-keyword">if</span> (accessToken) headers.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;accessToken&#125;</span>`</span>);

    <span class="hljs-keyword">return</span> headers;
  &#125;,
&#125;);</code></pre>

<p>The <code>baseQuery</code>, based on the incoming parameters from headers, just decides which token to assign to it, including setting the <code>Authorization</code> header with the <code>refreshToken</code> placeholder.<br>It’s 100% not the most elegant solution and will most likely be redone in the near future, but that’s how it is for now:</p>
<pre><code class="hljs tsx"><span class="hljs-keyword">try</span> &#123;
  <span class="hljs-keyword">const</span> refreshTokenResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">baseQuery</span>(<span class="hljs-comment">/* args */</span>);

  <span class="hljs-comment">// Check if we actually got tokens</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTokensResult</span>(refreshTokenResult?.<span class="hljs-property">data</span>)) &#123;
    <span class="hljs-comment">// If so, set &#x27;em and retry the same query</span>
    api.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">setAuthTokens</span>(refreshTokenResult.<span class="hljs-property">data</span>));
    result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">baseQuery</span>(args, api, extraOptions);
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// If not, just drop the session</span>
    api.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">logout</span>());
    api.<span class="hljs-title function_">dispatch</span>(baseApi.<span class="hljs-property">util</span>.<span class="hljs-title function_">resetApiState</span>());
  &#125;
&#125; <span class="hljs-keyword">finally</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;</code></pre>

<ol>
<li><p>Upon receiving the response, it checks if the <code>refreshTokenResult</code> contains valid tokens by calling the <code>isTokensResult</code> function.<br>It just verifies whether the data returned from the refresh request conforms to the expected token structure - simple TypeGuard.</p>
</li>
<li><p>If valid tokens are obtained, I dispatch the <code>setAuthTokens</code> action to update the authentication tokens in the Redux store.<br>Subsequently, it retries the original query that triggered the token refresh to ensure a seamless user experience.</p>
</li>
</ol>
<p>On the other hand, if the refresh request fails to provide valid tokens, user should be logged out with an error and a message to SignIn again.<br>I call the global <code>logout</code> action to log out the user and dispatch the <code>resetApiState</code> (from RTK Query) action to reset the API state, clearing any existing cached data.</p>
<p>By incorporating this token refresh logic, I ensure that the user’s access tokens are continuously updated, providing enhanced security and preventing unauthorized access to sensitive resources.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Implementing a mutex pattern for token refetch involved addressing the challenge of concurrent token refetch requests and efficiently managing the synchronization of these requests.</p>
<p>By leveraging a minimal implementation of the mutex pattern and incorporating error handling and recovery mechanisms, I achieved a reliable and secure solution.<br>This approach prevented race conditions and improved the efficiency of token refetching.</p>
<p>Good coding!</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/06/21/welcome/" title="Welcome to my Tech Bytes"><span class="has-text-weight-semibold">Next: Welcome to my Tech Bytes</span><i class="icofont-duotone icofont-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Twitter--><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/BlackRockSoul"><i class="icofont-github"></i></a><!-- Instagram--><!-- Linkedin--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/BlackRockSoul"><i class="icofont-linkedin"></i></a><!-- Facebook--><!-- CV--><a title="cv" target="_blank" rel="noopener nofollow" href="/cv/alex_petrov.pdf"><i class="icofont-file-pdf"></i></a><!-- RSS--></section><p><span>Copyright ©</span><span> BlackRockSoul 2023</span></p><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>